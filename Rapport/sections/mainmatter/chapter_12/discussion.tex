The following chapter, will take to consideration the choices made doing the different process of the project.
On this basis a discussion will be stated about the different choices and what could have been done differently.
\\\\
The sampling frequency used in this project is $44.1$ kHz the standard sampling frequency for audio signals.
The choice is made to make sure every frequency, within the audible frequency range, is able to be recreated per the sampling theorem \chr{ref til sampling?}
One of the highest frequency of an acoustic guitar, as the one used in this projects recording, without overtones is E$_5 = 659.26$ Hz.
Since this is well withing the range of the frequency that can be recreated, an argument could be made for using a lower sampling frequency.
This will lead to fewer data points, and would enable faster data processing or an eventual real time implementation. 
A reason the higher sampling frequency is chosen rather than lower sampling frequency, is that every frequency in the audible specter is of interest including the overtones of the played frequency and that the calculation aren't being done in real time.
Furthermore a lower sampling frequency will make the signal more susceptible to aliasing. %Kunne være sjovt at nedsample
%To test the signal and sampling frequency, the signal could be down sampled in an attempt to figure out a possible lower sampling frequency 
\chr{Noget af det syntes jeg måske passer bedre i perspektivering.}
%\\\\
%The choice of not implementing the algorithms in real time yadeyadeyada not relevant to be done live. \chr{Skal lige have en ide til hvordan man skal skrive det. og igen måske lidt mere perspektivering. og ikke så meget en diskution over valg i rapport}
\\\\
In the scripts/algorithms implemented in this project the chose of using a predefined algorithm for the FFT (as described in \chr{ref fft}) rather than hard coded FFT, is made due to the superior speed of the predefined function. 
Even though the algorithms isn't implemented in real time, the faster predefined numpy FFT drastically reduces a bottle neck in the algorithms.
\\\\
Using a FIR filter as in this project insures a fast implementation and a general linear phase.
The linear phase can be a wanted characteristic of filters to prevent phase distortion, but the higher order and more calculations of a fir filter, makes it worse for computer run time or a real time implementation. 
A possibility could be to implemented a IIR filter, for fewer calculation, but since the run time isn't a focus, the faster implementation of a FIR is an ideal choice as discussed in \ref{ch8}.
The 
\\\\
The Recording of music and noise 
In the recording of guitar tones, in this project, different choices was made to insure diversity and a wide range of frequencies.
Recording the guitar tones E$_2$ and E$_4$ gives insight into how lower and higher tones of the same harmonic behave, and a recording of a scale gives insight into some of the different tones between them.
In the scale, the different tones are played one after each other in a consecutive recording. 
An option could be to record each of the tones in the scale in there separate recording, enabling analysis of all the tones individually.
This could have been done to see how every tone behaves according to each other, but a coherent recording is more in line of a real recording of a song, and is therefore chosen as the given method.
\\\\
The peak detection algorithm is implemented over a final creation of a note sheet.
This algorithm is a close approximation to a note sheet, and the final symbol management is left out as described in \ref{ch3}.
The symbol management is decided to be left .
During the recording of the test audio, a timer between each note being played.
This makes the final product, the peak detection, unreliable in time and a multiple of the same note being played consecutive is indistinguishably from a long note of the same frequency.
This could have been circumvented by either using the previously mentioned timer, or theoretically using the audio file, timing each keystroke on the guitar.
Comparing this with the output time of the algorithm will be a necessity to create a final note sheet.





