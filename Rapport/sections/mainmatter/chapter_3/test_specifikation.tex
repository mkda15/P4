\section{Test specification}\label{sec:testspec}
In this section test specifications will be determined in order to validate the final system. This will be done upon the concept of the V-model illustrated in figure \ref{fig:vmodel}. \cite{vmodel} The V-model is a simple multiple-phase model used to describe phases in the development process. The left side of the V is decomposition of the problem - \textit{synthesising} , and the right side is the creation, integration, and test of the system - \textit{abstracting}.
\begin{figure}[H]
\centering
\tikzstyle{block} = [rectangle, draw,thick,fill=white, 
    text width=7em, text centered, minimum height=3.3em]
\tikzstyle{myarrows}=[line width=1mm,draw=blue,-triangle 45,postaction={draw, line width=3mm, shorten >=4mm, -}]
\begin{tikzpicture}[auto, node distance=1.6cm, >=triangle 45,font=\sffamily ]

\draw [myarrows](-1.8,1.2)--(5.3,-6.3);
\draw [myarrows](5.5,-5.9)--(12,1.2);
\draw 
	node [block](1){Concept of System}
	node [block, below of=1, right=0.7mm](2){Requirements and Architecture}
	node [block, below of=2, right=0.7mm](3){Detailed Design}
	node [block, below of=3, right=5mm](4){Implementation}
	node [block, above of=4, right=5mm](5){Unit Testing}
	node [block, above of=5, right=0.7mm](6){Integration Test}
	node [block, above of=6, right=0.7mm](7){System Test}
	node at (-0.7,-2) (11) {}
	node at (3.4,-6.5) (22) {}
	node at (12.9,0) (33)  {}
	node at (6.7,-6.5) (44) {}
;
\draw [<->, dashed](1)--(7);
\draw [<->, dashed](2)--(6);
\draw [<->, dashed](3)--(5);
\draw [decoration={text along path,
    text={Project Definition},text align={left}},decorate]  (11) -- (22);
\draw [decoration={text along path,
    text={Project Test and Integration},text align={center}},decorate]  (44) -- (33);
\end{tikzpicture}
\caption{Concept of the V-model}
\label{fig:vmodel}
\end{figure}

In the previous synthesis section requirements of the system was established. This section describes test specifications of each phase starting from the smallest unit, and working up to the system as a whole. \\
Detailed design, implementation and tests are described in chapter \ref{ch10}. \\
\\
The system will be tested from the bottom up, starting with the smallest components (single units). This validation phase is called the ``Unit Testing''. The test checks each of the units individually and verifies that they are working according to the expectations. Next up the coherence of the system is tested, and finally the full system as a whole unit is tested. Units in the model are as follows:
\begin{multicols}{2}
\subparagraph{Physical components}  
\begin{itemize}
	\item Microphone
	\item ADC
	\item Storage
\end{itemize}
\columnbreak
\subparagraph{Algorithm}
\begin{itemize}
	\item Filter
	\item Fourier transformation
	\item Spectrogram
	\item Peak detection
\end{itemize}
\end{multicols}
Note that tests on the physical components will not be carried out in this project because pretested hardware and corresponding software is used. Tests will thereby focus on the units of the application.
 
\subsubsection{Unit test of the Fourier transformation}
The Fourier transformation will be done by implementing the Fast Fourier Transformation described in section \ref{sec:FFT} 
To test the implementation it will be compared to the pre-existing FFT function from the Numpy-package in Python. These are compared by computing the time it takes for each function to compute different amounts of the same random numbers. Further this will be compared to an straight  implementation of the Discrete Fourier Transformation to see the effect of the Fast Fourier Transformation.

\subsubsection{Unit test of filter}
To validate the filter it will be tested whether the filter fulfil the specifications that are defined during the filter design process in chapter \ref{ch10}. In order to clarify the effect of the filter it will be tested on a simple known signal, where a noise signal has been digitally added. By this the frequency spectrum of both the pure signal and the noise is known and so is the signal to noise ratio. Hence, it is possible to verify whether the filter succeeds to remove the specified frequencies in order to reduce the noise. The verification will be made by analysing the frequency spectrum of the filtered signal compared to the original pure signal. 

\subsubsection{Unit test of STFT algorithm and spectrogram}
The spectrogram is made by the Short-Time Fourier Transform described in section \ref{sec:STFT}. As the verification of the Fourier Transformation described above, the spectrogram algorithm will be tested against an existing algorithm from the Numpy-package in Python on the same data set.
The algorithm will then be tested on a fixed data set with a known output. It will be a sine wave with three different frequencies. By doing so, the output of the algorithm can hence be compared.
Secondary the algorithm will be tested on a recorded signal to validate the implementation according to the data type that will act as the input in the final system. 
\frede{Her skal nok specificeres mere. Hvad er det pr√¶cis for noget data der er input/output? F.eks. en sinus i tid som bliver til en Dirac i frekvens \texttrademark}

\subsubsection{Unit test of the peak detection algorithm}
To validate the peak amplitude detector it will be tested on a recorded signal with known single tones. By table \ref{tab:tone} in chapter \ref{ch2} it is given that the significant frequency of a specific tone is defined. Thus the wanted output is known for comparison.         

\subsubsection{Integration validation}
When each unit is working according to the specifications the next step is to test the units as they are integrated into a single system. This test is done by taking the output of the previous unit and feeding it into the next unit of the algorithm. This is the last step in creating the final system.

\subsubsection{System test of the final application}
The final design will be tested by giving the final system a recording with a known result and comparing the difference between the application's result and the known result. The same test will be performed with different input files that vary in complexity.
\\
The music used for testing the application will be single tones, single chords, simple melodies containing only a single note at a time and also simple melodies with chords. The music is played with one instrument only. The single tones and melodies without chords will allow insight into the methods used without complicating the recognition of the tones by blending together different instruments and different sound frequencies. Naturally, it will be more difficult to recognize the tones in the single chords and melodies with chords. The recordings are described in appendix \ref{recordings}. 